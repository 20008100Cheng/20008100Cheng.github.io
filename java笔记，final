1)从程序设计语言的 理论上 : 局部内部类 (即:定义在方法中的内部类),由于本身就是在方法内部(可出现在形式参数定义处或者方法体处),因而 访问方法中的局部变量 (形式参数或局部变量)是 天经地义的 .是很自然的
2)为什么JAVA中要加上一条限制:只能访问final型的局部变量?
3)JAVA语言的编译程序的设计者当然全实现:局部内部类能访问方法中的所有的局部变量(因为:从理论上这是很自然的要求),但是: 编译技术是无法实现的或代价极高 .
4)困难在何处? 到底难在哪儿 ?
局部变量的生命周期与局部内部类的对象的生命周期的不一致性!
5)设方法f被调用,从而在它的调用栈中生成了变量i,此时产生了一个局部内部类对象inner_object,它访问了该局部变量i .当 方法f()运行结束后,局部变量i就已死亡了,不存在了. 但:局部内部类对象inner_object还可能一直存在(只能没有人再引用该对象时,它才会死亡),它不会随着方法f()运行结束死亡.这时:出现了 一个"荒唐"结果 :局部内部类对象inner_object 要访问一个已不存在的局部变量i!
6)如何才能实现?当变量是final时,通过将 final局部变量"复制"一份 ,复制品直接作为局部内部中的数据成员.这样:当局部内部类访问局部变量时,其实真正访问的是这个局部变量的"复制品"(即:这个复制品就代表了那个局部变量).因此:当运行栈中的 真正的局部变量死亡 时,局部内部类对象仍可以访问局部变量(其实访问的是"复制品"),给人的感觉: 好像是 局部变量的"生命期"延长了.
那么: 核心的问题是 :怎么才能使得: 访问"复制品" 与 访问 真正的 原始的局部变 量,其 语义效果是一样的 呢?
当变量是final时,若是基本数据类型,由于其值不变,因而:其复制品与原始的量是一样.语义效果相同.(若:不是final,就无法保证:复制品与原始变量保持一致了,因为:在 方法中改的是原始变量,而局部内部类中改的是复制品 )

当变量是final时,若是引用类型,由于其引用值不变(即:永远指向同一个对象),因而:其复制品与原始的引用变量一样,永远指向同一个对象(由于是final,从而保证:只能指向这个对象,再不能指向其它对象),达到:局部内部类中访问的复制品与方法代码中访问的原始对象,永远都是同一个即:语义效果是一样的. 否则 :当方法中改原始变量,而局部内部类中改复制品时,就 无法保证:复制品与原始变量保持一致了(因此:它们原本就应该是同一个变量.)

一句话:这个规定是一种无可奈何.也说明:程序设计语言的 设计 是 受到实现技术的限制 的.这就是一例. 因为:我就看到不少人都持这种观点:设计与想法是最重要的,实现的技术是无关紧要的,只要你作出设计与规定,都能实现.
